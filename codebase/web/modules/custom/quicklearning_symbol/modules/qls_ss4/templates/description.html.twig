{#

Description text for Section 4.

#}

{{ attach_library('core/drupal.dialog.ajax') }}

{% set qls_ss4_simple_transfer_transaction_form = path('qls_ss4.simple_transfer_transaction_form') %}
{% set qls_ss4_form_page = path('qls_ss4.form_page') %}

{% trans %}
<h2>トランザクション</h2>

<p>
ブロックチェーン上のデータ更新はトランザクションをネットワークにアナウンスすることによって行います。
</p>

<h3>4.1 トランザクションのライフサイクル</h3>
<p>
トランザクションを作成してから、改ざんが困難なデータとなるまでを順に説明します。
</p>

<p>
<ul>
<li>トランザクション作成
<span>– ブロックチェーンが受理できるフォーマットでトランザクションを作成します。</span>
</li>
<li>署名
<span>– アカウントの秘密鍵でトランザクションを署名します。</span>
</li>
<li>アナウンス
<span>– 任意のノードに署名済みトランザクションを通知します。</span>
</li>
<li>未承認トランザクション
<span>– ノードに受理されたトランザクションは、未承認トランザクションとして全ノードに伝播します。</span>
∗ トランザクションに設定した最大手数料が、各ノード毎に設定されている最低手数料を満たさない場合はそのノードへは伝播しません。
</li>
<li>承認済みトランザクション
<span>– 約30 秒に1 度ごとに生成されるブロックに未承認トランザクションが取り込まれると、承認済みトランザクションとなります。</span>
</li>
<li>ロールバック
<span>– ノード間の合意に達することができずロールバックされたブロックに含まれていたトランザクションは、未承認トランザクションに差し戻されます。</span>
∗ 有効期限切れや、キャッシュからあふれたトランザクションは切り捨てられます。
</li>
<li>ファイナライズ
<span>– 投票ノードによるファイナライズプロセスによりブロックが確定するとトランザクションはロールバック不可なデータとして扱うことができます。</span>
</li>
</p>
<p>
これらがブロックチェーンを操作するための最も基本的な情報となります。
また、秘密鍵からアカウントを生成したり、公開鍵やアドレスのみを扱うクラスの生成方法も確認しておきましょう。
</p>

<h3>4.1.1 ブロックとは</h3>
<p>
ブロックは約30 秒ごとに生成され、高い手数料を支払ったトランザクションから優先に取り込まれ、
ブロック単位で他のノードと同期します。同期に失敗するとロールバックして、
ネットワークが全体で合意が取れるまでこの作業を繰り返します。
</p>

<h4><a href={{ qls_ss4_simple_transfer_transaction_form }}>4.2 トランザクション作成 4.3 署名とアナウンス 4.4 確認 4.4.1 ステータスの確認</a></h4>
<p>
まずは最も基本的な転送トランザクションを作成してみます。
</p>
<p>
作成したトランザクションを秘密鍵で署名して、任意のノードを通じてアナウンスします。
</p>
<code>
"message": "packet 9 was pushed to the network via \/transactions"
</code>
<p>
上記のスクリプトのようにpacket n was pushed to the network というレスポンスがあれば、トランザクションはノードに受理されたことになります。
これはトランザクションのフォーマット等に異常が無かった程度の意味しかありません。
Symbol ではノードの応答速度を極限に高めるため、トランザクションの内容を検証するまえに受信結果の応答を返し接続を切断します。
レスポンス値はこの情報を受け取ったにすぎません。
フォーマットに異常があった場合は以下のようなメッセージ応答があります。
</p>
<span>■アナウンスに失敗した場合の応答例</span>
<code>
Uncaught Error: {
"statusCode":409,
"statusMessage":"Unknown Error",
"body":
"{\"code\":\"InvalidArgument\",\"message\":\"payload has an invalid format\"}"
}
</code>

<p>ノードに受理されたトランザクションのステータスを確認</p>

<h4>4.4.2 承認確認</h4>
<p>トランザクションがブロックに承認されるまでに30 秒程度かかります。</p>
<p>
エクスプローラーで確認
signedTx.hash で取得できるハッシュ値を使ってエクスプローラーで検索してみましょう。
</p>
<p>
■注意点 トランザクションはブロックで承認されたとしても、ロールバックが発生するとトランザクションの承認が取り消される場合があります。
ブロックが承認された後、数ブロックの承認が進むと、ロールバックの発生する確率は減少していきます。
また、Voting ノードの投票で実施されるファイナライズブロックを待つことで、記録されたデータは確実なものとなります。
</p>
<p>
■スクリプト例 トランザクションをアナウンスした後は以下のようなスクリプトを流すと、チェーンの状態を把握しやすくて便利です。
※途中sleep を入れているのはアナウンスより先にステータスを確認しに行ってしまいエラーを返す可能性があるためです。
</p>

<h3>4.5 トランザクション履歴</h3>
<p>Alice が送受信したトランザクション履歴を一覧で取得します。</p>

<h4>4.5.1 Tx ペイロード作成時のメッセージの差異</h4>
<p>【未検証のため検証後執筆予定】</p>

<h3><a href={{ qls_ss4_form_page }}>4.6 アグリゲートトランザクション</a></h3>
<p>
Symbol では複数のトランザクションを1 ブロックにまとめてアナウンスすることがで
きます。最大で100 件のトランザクションをまとめることができます（連署者が異なる
場合は25 アカウントまでを連署指定可能）。以降の章で扱う内容にアグリゲートトラン
ザクションへの理解が必要な機能が含まれますので、本章ではアグリゲートトランザク
ションのうち、簡単なものだけを紹介します。
</p>
<p>
まず、アグリゲートトランザクションに含めるトランザクションを作成します。このと
きDeadline を指定する必要はありませんがnetwork は必ず指定してください。（指定し
ない場合Failure_Core_Wrong_Network が発生します）リスト化するときに、生成し
たトランザクションにtoAggregate を追加して送信元アカウントの公開鍵を指定します。
ちなみに送信元アカウントと署名アカウントが必ずしも一致するとは限りません。後の章
での解説で「Bob の送信トランザクションをAlice が署名する」といった事が起こり得る
ためこのような書き方をします。これはSymbol ブロックチェーンでトランザクションを
扱ううえで最も重要な概念になります。なお、本章で扱うトランザクションは同じAlice
ですので、アグリゲートボンデッドトランザクションへの署名もAlice を指定します。
</p>

<h4>4.6.1 アグリゲートトランザクションにおける最大手数料</h4>
<p>
アグリゲートトランザクションも通常のトランザクション同様、最大手数料を直接指定
する方法とfeeMultiprier で指定する方法があります。先の例では最大手数料を直接指定
する方法を使用しました。ここではfeeMultiprier で指定する方法を紹介します。
</p>

<h3>4.7 現場で使えるヒント</h3>
<p>
存在証明アカウントの章でアカウントによるデータの署名と検証する方法について説明しました。このデータをトランザクションに載せてブロックチェーンが承認することで、
アカウントがある時刻にあるデータの存在を認知したことを消すことができなくなります。タイムスタンプの刻印された電子署名を利害関係者間で所有することと同じ意味が
あると考えることもできます。（法律的な判断は他の方にお任せします）ブロックチェーンは、この消せない「アカウントが認知したという事実」の存在をもっ
て送信などのデータ更新を行います。
また、誰もがまだ知らないはずの事実を知っていたことの証明としてブロックチェーンを利用することもできます。
ここでは、その存在が証明されたデータをトランザクションに載せる２つの方法について説明します。
デジタルデータのハッシュ値(SHA256) 出力方法ファイルの要約値をブロックチェーンに記録することでそのファイルの存在を証明することができます。
各OS ごとのファイルのSHA256 でハッシュ値を計算する方法は下記の通りです。
</p>
<code>
#Windows
certutil -hashfile WINファイルパス SHA256
#Mac
shasum -a 256 MACファイルパス
#Linux
sha256sum Linuxファイルパス
</code>

<h4>4.7.1 大きなデータの分割</h4>
<p>
トランザクションのペイロードには1023 バイトしか格納できないため、大きなデータは分割してペイロードに詰め込んでアグリゲートトランザクションにします。
</p>

{% endtrans %}
