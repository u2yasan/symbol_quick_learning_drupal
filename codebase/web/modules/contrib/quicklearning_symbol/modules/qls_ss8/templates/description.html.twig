{#

Description text for Section 8.

#}

{{ attach_library('core/drupal.dialog.ajax') }}


{% set qls_ss8_hash_lock_form = path('qls_ss8.hash_lock_form') %}
{% set qls_ss8_secret_lock_form = path('qls_ss8.secret_lock_form') %}
{% set qls_ss8_secret_proof_form = path('qls_ss8.secret_proof_form') %}

{% trans %}
<h2>第8 章 ロック</h2>

<p>
Symbol ブロックチェーンにはハッシュロックとシークレットロックの２種類のロック機構があります。
</p>

<h3>8.1 ハッシュロック</h3>
<p>
ハッシュロックは後でアナウンスされる予定のトランザクションを事前にハッシュ値で登録しておくことで、
該当トランザクションがアナウンスされた場合に、そのトランザクションをAPI ノード上で処理せずにロックさせて、
署名が集まってから処理を行うことができます。
アカウントが所有するモザイクを操作できないようにロックするわけではなく、
ロックされるのはハッシュ値の対象となるトランザクションとなります。
ハッシュロックにかかる費用は10XYM、有効期限は最大約48 時間です。ロックしたトランザクションが承認されれば10XYM は返却されます。
</p>

<h4><a href={{ qls_ss8_hash_lock_form }}>8.1.1 アグリゲートボンデッドトランザクションの作成</a></h4>
<p>
tx1,tx2 の2 つのトランザクションをaggregateArray で配列にする時に、送信元アカウントの公開鍵を指定します。
公開鍵はアカウントの章を参考に事前にAPI で取得しておきましょう。
配列化されたトランザクションはブロック承認時にその順序で整合性を検証されます。
例えば、tx1 でNFT をAlice からBob へ送信した後、tx2 でBob からCarol へ同じNFT を送信することは可能ですが、
tx2,tx1 の順序でアグリゲートトランザクションを通知するとエラーになります。
また、アグリゲートトランザクションの中に1 つでも整合性の合わないトランザクションが存在していると、
アグリゲートトランザクション全体がエラーとなってチェーンに承認されることはありません。
</p>



<h4><a href={{ qls_ss8_hash_lock_form }}>8.1.2 ハッシュロックトランザクションの作成と署名、アナウンス</a></h4>
<h4>8.1.3 アグリゲートボンデッドトランザクションのアナウンス</h4>
<h4>8.1.4 連署</h4>
<h4>8.1.5 注意点</h4>
<p>
ハッシュロックトランザクションは起案者(トランザクションを作成し最初に署名するアカウント) に限らず、
誰が作成してアナウンスしても大丈夫ですが、アグリゲートトランザクションにそのアカウントがsigner となるトランザクションを含めるようにしてください。
モザイク送信無し＆メッセージ無しのダミートランザクションでも問題ありません（パフォーマンスに影響が出るための仕様とのことです）
また、ハッシュロックトランザクションが承認された直後にボンデッドトランザクションをアナウンスした場合、
ハッシュロックの承認がネットワーク全体に伝播する前にボンデッドトランザクションを受け取ってしまうノードが出てくる可能性があります。
そのような状態を防ぐために、ボンデッドトランザクションはハッシュロックトランザクションが承認された後しばらく待ってからアナウンスするようにしてください。
</p>

<h3>8.2 シークレットロック・シークレットプルーフ</h3>

<p>
シークレットロックは事前に共通パスワードを作成しておき、指定モザイクをロックします。
受信者が有効期限内にパスワードの所有を証明することができればロックされたモザイクを受け取ることができる仕組みです。
ここではAlice が1XYM をロックしてBob が解除することで受信する方法を説明します。
ロック解除にBob 側からトランザクションをアナウンスする必要があるのでFAUCETで10XYM ほど受信しておきます。
</p>
<h4><a href={{ qls_ss8_secret_lock_form }}>8.2.1 シークレットロック</a></h4>
<p>
ロック・解除にかかわる共通暗号を作成します。
PHP ではSHA3-256 ハッシュ関数を提供するライブラリをインストールします。
</p>
<code>
composer require symfony/polyfill-php70
</code>
<p>
トランザクションを作成・署名・アナウンスします
</p>
<p>
LockHashAlgorithm は以下の通りです。
</p>
<code>{0:'Op_Sha3_256', 1:'Op_Hash_160', 2:'Op_Hash_256'}</code>
<p>
ロック時に解除先を指定するのでBob 以外のアカウントが解除しても転送先（Bob）を変更することはできません。
ロック期間は最長で365 日(ブロック数を日換算) までです。
承認されたトランザクションを確認します。
</p>
<p>
ロックしたAlice がownerAddress、受信予定のBob がrecipientAddress に記録され
ています。secret 情報が公開されていて、これに対応するproof をBob がネットワーク
に通知します。
</p>

<h4><a href={{ qls_ss8_secret_proof_form }}>8.2.2 シークレットプルーフ</a></h4>
<p>
解除用キーワードを使用してロック解除します。Bob は事前に解除用キーワードを入手しておく必要があります。
</p>
<p>
承認結果を確認します。
</p>
<p>
SecretProofTransaction にはモザイクの受信量の情報は含まれていません。
ブロック生成時に作成されるレシートで受信量を確認します。
レシートタイプ:LockSe-cret_Completed でBob 宛のレシートを検索してみます。
</p>
<p>
ReceiptType は以下の通りです。
</p>

<code>
{
  4685: 'Mosaic_Rental_Fee',
  4942: 'Namespace_Rental_Fee',
  8515: 'Harvest_Fee',
  8776: 'LockHash_Completed',
  8786: 'LockSecret_Completed',
  9032: 'LockHash_Expired',
  9042: 'LockSecret_Expired',
  12616: 'LockHash_Created',
  12626: 'LockSecret_Created',
  16717: 'Mosaic_Expired',
  16718: 'Namespace_Expired',
  16974: 'Namespace_Deleted',
  20803: 'Inflation',
  57667: 'Transaction_Group',
  61763: 'Address_Alias_Resolution'
  62019: 'Mosaic_Alias_Resolution',
}
8786: 'LockSecret_Completed' :ロック解除完了
9042: 'LockSecret_Expired' ：ロック期限切れ
</code>

<h3>8.3 現場で使えるヒント</h3>
<h4>8.3.1 手数料代払い</h4>
<p>
一般的にブロックチェーンはトランザクション送信に手数料を必要とします。
そのため、ブロックチェーンを利用しようとするユーザは事前に手数料を取引所から入手しておく必要があります。
このユーザが企業である場合はその管理方法も加えてさらにハードルの高い問題となります。
アグリゲートトランザクションを使用することでハッシュロック費用と
ネットワーク手数料をサービス提供者が代理で負担することができます。
</p>
<h4>8.3.2 タイマー送信</h4>
<p>
シークレットロックは指定ブロック数を経過すると元のアカウントへ払い戻されます。
この原理を利用して、シークレットロックしたアカウントにたいしてロック分の費用をサービス提供者が充足しておけば、
期限が過ぎた後ユーザ側がロック分のトークン所有量が増加することになります。
一方で、期限が過ぎる前にシークレット証明トランザクションをアナウンスすると、
送信が完了し、サービス提供者に充当戻るためキャンセル扱いとなります。
</p>
<h4>8.3.3 アトミックスワップ</h4>
<p>
シークレットロックを使用して、他のチェーンとのトークン・モザイクの交換を行うことができます。
他のチェーンではハッシュタイムロックコントラクト(HTLC) と呼ばれているためハッシュロックと間違えないようにご注意ください。
</p>

{% endtrans %}
